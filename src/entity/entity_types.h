// clang-format off
/*
 * Do not edit this file directly! It is generated from
 * `tools/entity_types.h` by the build system at compile time.
 */

#pragma once
#include <typeinfo>
#include <algorithm>

#include "entity.h"
#include "../util/util.h"

#include "../asset/asset.h"
#include "../audio.h"
#include "../math/types.h"

enum class EntityType {
    BASEENTITY,
    BLOCK,
    ENTITY,
    LIGHT,
    PLAYER,
    SOUNDENTITY,

    NUM_ENTITY_TYPES,
};

using FieldNameType = const char *;
namespace FieldName {
extern FieldNameType asset_id;
extern FieldNameType audio_id;
extern FieldNameType color;
extern FieldNameType draw_as_point;
extern FieldNameType entity_id;
extern FieldNameType hit;
extern FieldNameType hp;
extern FieldNameType last_input;
extern FieldNameType light_id;
extern FieldNameType position;
extern FieldNameType remove;
extern FieldNameType rotation;
extern FieldNameType scale;
extern FieldNameType sound_source_settings;
extern FieldNameType type;
extern FieldNameType velocity;
};

static const char *entity_type_names[] = {
    "BaseEntity",
    "Block",
    "Entity",
    "Light",
    "Player",
    "SoundEntity"
};

i32 format(char *, u32, FormatHint, EntityType);

struct Field {
    const std::type_info &typeinfo;
    const char *name;
    int size;
    int offset;
    bool internal;
};

struct FieldList {
    int num_fields;
    Field *list;
};

static constexpr int MAX_ENTITY_SIZE = std::max({sizeof(BaseEntity), sizeof(Block), sizeof(Entity), sizeof(Light), sizeof(Player), sizeof(SoundEntity)});

///*
// Returns a list of fields on the specified struct type.
FieldList get_fields_for(EntityType type);

///*
// Populates the memory with a valid entity of the given
// type. The function assumes that the buffer size
// is larger than MAX_ENTITY_SIZE.
void emplace_entity(void *buffer, EntityType type);

/*
 * Included from `tools/entity_types_type_of.h`
 */

struct BaseEntity;
EntityType type_of(BaseEntity *);

struct Block;
EntityType type_of(Block *);

struct Entity;
EntityType type_of(Entity *);

struct Light;
EntityType type_of(Light *);

struct Player;
EntityType type_of(Player *);

struct SoundEntity;
EntityType type_of(SoundEntity *);

/*
 * End of `tools/entity_types_type_of.h`
 */

struct EventCreateEntity {
    bool generate_id;
    EntityType type;
    union {
        u8 BASEENTITY[sizeof(BaseEntity) - sizeof(void *)];
        u8 BLOCK[sizeof(Block) - sizeof(void *)];
        u8 ENTITY[sizeof(Entity) - sizeof(void *)];
        u8 LIGHT[sizeof(Light) - sizeof(void *)];
        u8 PLAYER[sizeof(Player) - sizeof(void *)];
        u8 SOUNDENTITY[sizeof(SoundEntity) - sizeof(void *)];
    };

    void callback();
};

struct Event;

Event entity_event(BaseEntity entity, bool generate_id = false);
Event entity_event(BaseEntity *entity, bool generate_id = false);
Event entity_event(Block entity, bool generate_id = false);
Event entity_event(Block *entity, bool generate_id = false);
Event entity_event(Entity entity, bool generate_id = false);
Event entity_event(Entity *entity, bool generate_id = false);
Event entity_event(Light entity, bool generate_id = false);
Event entity_event(Light *entity, bool generate_id = false);
Event entity_event(Player entity, bool generate_id = false);
Event entity_event(Player *entity, bool generate_id = false);
Event entity_event(SoundEntity entity, bool generate_id = false);
Event entity_event(SoundEntity *entity, bool generate_id = false);
